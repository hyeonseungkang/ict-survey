<html>
<head>
    <title>survey 테스트</title>
</head>
<body>
<h1>survey 테스트</h1>
<video width="500px" height="300px"></video>
<script>
    const videoElement = document.querySelector('video')
    const mimeType = 'video/mp4'
    const chunks = []
    function autoDownloadBlob(blob, filename){
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
    }
    navigator.mediaDevices.getUserMedia({video: true}).then(async stream => {
        videoElement.srcObject = stream
        await videoElement.play()
        // const root = await navigator.storage.getDirectory();
        // const dir = await root.getDirectoryHandle('/videos', {create: true})
        // const fileHandle = await dir.getFileHandle(`${Date.now()}.mp4`, {create: true})
        // const writable = await fileHandle.createWritable()
        const recoder = new MediaRecorder(stream, {mimeType, videoBitsPerSecond: 6_000_000})
        recoder.ondataavailable = e => {
            if (e.data && e.data.size) chunks.push(e.data);
        };
        recoder.onstop = async () => {
            const blob = new Blob(chunks, {type: mimeType});
            // await writable.write(blob)
            // await writable.close()
            autoDownloadBlob(blob)
            videoElement.srcObject = null;
            stream.getTracks().forEach(t => t.stop());
        };
        recoder.start(1000)
        setTimeout(() => {
            recoder.stop()
        }, 5000)
    })
    alert(`is h264 codec support? ${MediaRecorder.isTypeSupported(mimeType)}`)
    // try {
    //     navigator.storage.getDirectory();
    //     alert('opfs available')
    // } catch {
    //     alert('opfs not available')
    // }
</script>
</body>
</html>
